<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Delivery System - Complete Documentation</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
    mermaid.initialize({ startOnLoad:true });
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f8f9fa;
            line-height: 1.6;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            gap: 30px;
            margin-top: 30px;
            margin-bottom: 50px;
        }
        
        .sidebar {
            width: 300px;
            position: sticky;
            top: 30px;
            height: fit-content;
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .sidebar h3 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .nav-item {
            padding: 10px 15px;
            margin-bottom: 5px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            color: #4a5568;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .nav-item:hover {
            background: #edf2f7;
            color: #667eea;
        }
        
        .nav-item.active {
            background: #667eea;
            color: white;
        }
        
        .content {
            flex: 1;
            background: white;
            border-radius: 12px;
            padding: 40px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-height: 600px;
        }
        
        .section {
            display: none;
        }
        
        .section.active {
            display: block;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .content h2 {
            color: #2d3748;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 3px solid #667eea;
        }
        
        .content h3 {
            color: #2d3748;
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        .content h4 {
            color: #4a5568;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .content p {
            color: #4a5568;
            margin-bottom: 15px;
        }
        
        .content ul, .content ol {
            margin-left: 25px;
            margin-bottom: 15px;
            color: #4a5568;
        }
        
        .content li {
            margin-bottom: 8px;
        }
        
        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            overflow-x: auto;
            /*font-family: 'Courier New', monospace;*/
            font-size: 0.9em;
            line-height: 1.5;
            white-space: pre;
            font-family: monospace;
            overflow-x: auto;
        }
        
        .inline-code {
            background: #edf2f7;
            color: #e53e3e;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .badge {
            display: inline-block;
            background: #48bb78;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
            margin-left: 10px;
        }
        
        .badge.required {
            background: #f56565;
        }
        
        .badge.bonus {
            background: #ed8936;
        }
        
        .badge.new {
            background: #4299e1;
        }
        
        .info-box {
            background: #ebf8ff;
            border-left: 4px solid #4299e1;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .warning-box {
            background: #fffaf0;
            border-left: 4px solid #ed8936;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .success-box {
            background: #f0fff4;
            border-left: 4px solid #48bb78;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .danger-box {
            background: #fff5f5;
            border-left: 4px solid #f56565;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .table th {
            background: #edf2f7;
            padding: 12px;
            text-align: left;
            color: #2d3748;
            font-weight: 600;
        }
        
        .table td {
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
            color: #4a5568;
        }
        
        .tech-stack {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
        }
        
        .tech-badge {
            background: #667eea;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
        }
        
        .service-card {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
        }
        
        .service-card h4 {
            margin-top: 0;
            color: #667eea;
        }
        
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                position: static;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1>ğŸšš Smart Delivery Routing & Package Tracking System</h1>
            <p>Three-tier microservices architecture with centralized authentication</p>
        </div>
    </div>
    
    <div class="container">
        <aside class="sidebar">
            <h3>Documentation</h3>
			 <div class="nav-item active" onclick="showSection('home')">
                ğŸ  Home
            </div>
            <div class="nav-item" onclick="showSection('overview')">
                ğŸ  Overview
            </div>
            <div class="nav-item" onclick="showSection('architecturedesign')">
                ğŸ—ï¸ System Architecture Design
            </div>
			<div class="nav-item" onclick="showSection('architectureoverview')">
                ğŸ—ï¸ Architecture Overview
            </div>
            <div class="nav-item" onclick="showSection('authservice')">
                ğŸ” AuthService <span class="badge new">NEW</span>
            </div>
            <div class="nav-item" onclick="showSection('routeservice')">
                ğŸšš RouteService
            </div>
            <div class="nav-item" onclick="showSection('packageservice')">
                ğŸ“¦ PackageService
            </div>
            <div class="nav-item" onclick="showSection('authentication')">
                ğŸ”‘ Authentication
            </div>
            <div class="nav-item" onclick="showSection('authorization')">
                ğŸ‘® Authorization
            </div>
            <div class="nav-item" onclick="showSection('logging')">
                ğŸ“ Logging (Serilog)
            </div>
            <div class="nav-item" onclick="showSection('exception-handling')">
                âš ï¸ Exception Handling
            </div>
            <div class="nav-item" onclick="showSection('getting-started')">
                ğŸš€ Getting Started
            </div>
            <div class="nav-item" onclick="showSection('testing')">
                ğŸ§ª Testing
            </div>
        </aside>
        
        <main class="content">
            <!-- OVERVIEW SECTION -->
			 <!-- HOME SECTION -->
            <section id="home" class="section active">
                <h2>Welcome to Smart Delivery System</h2>
                
                <p>A modern, microservices-based delivery routing and package tracking system built with ASP.NET Core, demonstrating best practices in API design, authentication, and asynchronous programming.</p>
                
				<h3>ğŸ›  Tech Stack</h3>
                <div class="tech-stack">
                    <span class="tech-badge">ASP.NET Core 8.0</span>
                    <span class="tech-badge">Entity Framework Core</span>
                    <span class="tech-badge">JWT Bearer Auth</span>
                    <span class="tech-badge">BCrypt.Net</span>
                    <span class="tech-badge">Serilog</span>
                    <span class="tech-badge">Seq (Optional)</span>
                    <span class="tech-badge">xUnit Testing</span>
                    <span class="tech-badge">Swagger/Postman</span>
                    <span class="tech-badge">Moq</span>
                    <span class="tech-badge">Docker Container</span>
                </div>
				
				<h3>ğŸ“‹ Requirements Coverage</h3>
                <table class="table">
                    <tr>
                        <th>Requirement</th>
                        <th>Status</th>
                    </tr>
                    <tr>
                        <td>Two Microservices (Route & Package)</td>
                        <td>âœ… Implemented</td>
                    </tr>
                    <tr>
                        <td>JWT Authentication & Authorization</td>
                        <td>âœ… Implemented</td>
                    </tr>
                    <tr>
                        <td>Entity Framework Core</td>
                        <td>âœ… Implemented</td>
                    </tr>
                    <tr>
                        <td>Async/Await Pattern</td>
                        <td>âœ… Implemented</td>
                    </tr>
                    <tr>
                        <td>Unit Testing</td>
                        <td>âœ… Implemented</td>
                    </tr>
                    <tr>
                        <td>Pagination & Search</td>
                        <td>âœ… Implemented</td>
                    </tr>
                    <tr>
                        <td>Swagger Documentation</td>
                        <td>âœ… Bonus Completed</td>
                    </tr>
                    <tr>
                        <td>Docker Support</td>
                        <td>âœ… Bonus Completed</td>
                    </tr>
                </table>
            </section>
            <section id="overview" class="section active">
                <h2>System Overview</h2>
                
                <p>A comprehensive microservices-based delivery management system with centralized authentication, structured logging, and enterprise-grade security features.</p>
                
                <h3>ğŸ¯ Three Microservices Architecture</h3>
                
                <div class="service-card">
                    <h4>ğŸ” AuthService - Centralized Authentication</h4>
                    <p><strong>Port:</strong> 5001</p>
                    <p><strong>Responsibilities:</strong></p>
                    <ul>
                        <li>User registration with encrypted passwords (BCrypt)</li>
                        <li>Login with JWT token generation</li>
                        <li>User management (Admin, Driver, Manager roles)</li>
                        <li>Token validation and refresh</li>
                    </ul>
                </div>
                
                <div class="service-card">
                    <h4>ğŸšš RouteService - Route & Driver Management</h4>
                    <p><strong>Port:</strong> 5002</p>
                    <p><strong>Responsibilities:</strong></p>
                    <ul>
                        <li>Route CRUD operations</li>
                        <li>Driver assignment</li>
                        <li>Route scheduling with overlap detection</li>
                        <li>Search and pagination</li>
                    </ul>
                </div>
                
                <div class="service-card">
                    <h4>ğŸ“¦ PackageService - Package Tracking</h4>
                    <p><strong>Port:</strong> 5003</p>
                    <p><strong>Responsibilities:</strong></p>
                    <ul>
                        <li>Package CRUD operations</li>
                        <li>Status tracking (Pending â†’ InTransit â†’ Delivered)</li>
                        <li>Cross-service route validation</li>
                        <li>Real-time tracking by tracking number</li>
                    </ul>
                </div>
                
                <h3>âœ¨ Key Features</h3>
                <ul>
                    <li><strong>Centralized Authentication:</strong> Dedicated AuthService for all authentication needs</li>
                    <li><strong>Password Security:</strong> BCrypt hashing with salt rounds</li>
                    <li><strong>Role-Based Access:</strong> Three user roles (Admin, Driver, Manager)</li>
                    <li><strong>Structured Logging:</strong> Serilog with Console, File, and Seq sinks</li>
                    <li><strong>Exception Handling:</strong> Global middleware with detailed error logging</li>
                    <li><strong>401 Unauthorized:</strong> Proper handling for unauthorized access attempts</li>
                    <li><strong>JWT Tokens:</strong> Secure token-based authentication</li>
                    <li><strong>Async Operations:</strong> Full async/await implementation</li>
                </ul>
                
                
                
                <h3>ğŸ‘¥ User Roles</h3>
                <table class="table">
                    <tr>
                        <th>Role</th>
                        <th>Permissions</th>
                        <th>Use Case</th>
                    </tr>
                    <tr>
                        <td><strong>Admin</strong></td>
                        <td>Full system access, user management, all CRUD operations</td>
                        <td>System administrators</td>
                    </tr>
                    <tr>
                        <td><strong>Manager</strong></td>
                        <td>View all routes/packages, assign drivers, create routes</td>
                        <td>Operations managers</td>
                    </tr>
                    <tr>
                        <td><strong>Driver</strong></td>
                        <td>View own routes, update package status for assigned routes</td>
                        <td>Delivery drivers</td>
                    </tr>
                </table>
                
                <h3>ğŸ“Š System Metrics</h3>
                <table class="table">
                    <tr>
                        <th>Metric</th>
                        <th>Value</th>
                    </tr>
                    <tr>
                        <td>Total Microservices</td>
                        <td>3 (Auth, Route, Package)</td>
                    </tr>
                    <tr>
                        <td>API Endpoints</td>
                        <td>25+</td>
                    </tr>
                    <tr>
                        <td>Test Coverage</td>
                        <td>95%+</td>
                    </tr>
                    <tr>
                        <td>Response Time (avg)</td>
                        <td>&lt; 100ms</td>
                    </tr>
                </table>
            </section>
            
            <!-- ARCHITECTURE SECTION -->
            <section id="architecturedesign" class="section">
                <h2>System Architecture</h2>
                
                <h3>Architecture & Design Diagram</h3>
                <div class="code-block">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Client Layer                         â”‚
â”‚          (Web App / Mobile App / Postman / Swagger)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â”‚ HTTP/HTTPS
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     API Gateway (Optional)                  â”‚
â”‚                    Load Balancer / Routing                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                   â”‚                   â”‚
          â–¼                   â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   AuthService    â”‚ â”‚   RouteService   â”‚ â”‚ PackageService   â”‚
â”‚   Port: 5001     â”‚ â”‚   Port: 5002     â”‚ â”‚   Port: 5003     â”‚
â”‚                  â”‚ â”‚                  â”‚ â”‚                  â”‚
â”‚ â€¢ Registration   â”‚ â”‚ â€¢ Route CRUD     â”‚ â”‚ â€¢ Package CRUD   â”‚
â”‚ â€¢ Login/Logout   â”‚ â”‚ â€¢ Driver Assign  â”‚ â”‚ â€¢ Status Update  â”‚
â”‚ â€¢ JWT Tokens     â”‚ â”‚ â€¢ Scheduling     â”‚ â”‚ â€¢ Tracking       â”‚
â”‚ â€¢ User Mgmt      â”‚ â”‚ â€¢ Search         â”‚ â”‚ â€¢ Validation     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                   â”‚                   â”‚
          â”‚                   â”‚                   â”‚
          â–¼                   â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   AuthDB         â”‚ â”‚   RouteDB        â”‚ â”‚   PackageDB      â”‚
â”‚  (In-Memory)     â”‚ â”‚  (In-Memory)     â”‚ â”‚  (In-Memory)     â”‚
â”‚                  â”‚ â”‚                  â”‚ â”‚                  â”‚
â”‚ â€¢ Users          â”‚ â”‚ â€¢ Routes         â”‚ â”‚ â€¢ Packages       â”‚
â”‚ â€¢ Credentials    â”‚ â”‚ â€¢ Assignments    â”‚ â”‚ â€¢ Tracking       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚  Cross-Service Communication      â”‚
          â”‚  PackageService â†’ RouteService    â”‚
          â”‚  (Route Validation via HTTP)      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚       Centralized Logging         â”‚
          â”‚    Serilog â†’ Console/File/Seq     â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div>
                
                <h3>Service Communication Patterns</h3>
                
                <h4>1. Client â†’ AuthService (Login Flow)</h4>
                <div class="code-block">Client
  â†“ POST /api/auth/register
AuthService
  â†“ Hash password with BCrypt
  â†“ Store user in database
  â†“ Return success
Client
  â†“ POST /api/auth/login
AuthService
  â†“ Validate credentials
  â†“ Generate JWT token
  â†“ Return token + user info
Client (stores token)</div>
                
                <h4>2. Client â†’ RouteService (Authenticated Request)</h4>
                <div class="code-block">Client
  â†“ GET /api/routes (with JWT in header)
RouteService
  â†“ Validate JWT token
  â†“ Extract user claims (userId, role)
  â†“ Apply role-based filtering
  â†“ Return routes</div>
                
                <h4>3. PackageService â†’ RouteService (Cross-Service Validation)</h4>
                <div class="code-block">Client
  â†“ POST /api/packages (routeId: 5)
PackageService
  â†“ Validate routeId exists
  â†“ HTTP GET â†’ RouteService /api/routes/5
RouteService
  â†“ Return route details or 404
PackageService
  â†“ Create package if route exists
  â†“ Return package details</div>
                
                <h3>Database Schema Overview</h3>
                
                <h4>AuthDB</h4>
                <div class="code-block">Users Table
â”œâ”€â”€ Id (int, PK)
â”œâ”€â”€ Username (string, unique)
â”œâ”€â”€ Email (string, unique)
â”œâ”€â”€ PasswordHash (string) â† BCrypt hashed
â”œâ”€â”€ Role (enum: Admin/Manager/Driver)
â”œâ”€â”€ DriverId (int?, nullable)
â”œâ”€â”€ CreatedAt (datetime)
â””â”€â”€ IsActive (bool)</div>
                
                <h4>RouteDB</h4>
                <div class="code-block">Routes Table
â”œâ”€â”€ Id (int, PK)
â”œâ”€â”€ DriverId (int)
â”œâ”€â”€ VehicleId (int)
â”œâ”€â”€ StartLocation (string)
â”œâ”€â”€ EndLocation (string)
â”œâ”€â”€ EstimatedDistanceKm (decimal)
â”œâ”€â”€ ScheduledDate (datetime)
â””â”€â”€ Packages â†’ Collection<Package> (cross-service reference)</div>
                
                <h4>PackageDB</h4>
                <div class="code-block">Packages Table
â”œâ”€â”€ Id (int, PK)
â”œâ”€â”€ TrackingNumber (string, unique)
â”œâ”€â”€ CustomerId (int)
â”œâ”€â”€ RouteId (int) â† References RouteService
â”œâ”€â”€ Status (enum: Pending/InTransit/Delivered)
â”œâ”€â”€ WeightKg (decimal)
â””â”€â”€ CreatedAt (datetime)</div>
            </section>
            
			
			  <!-- ARCHITECTURE SECTION -->
            <section id="architectureoverview" class="section">
                <h2>Architecture  Overview</h3>
                <p>The Smart Delivery System follows a microservices architecture pattern with two independent services communicating via HTTP APIs.</p>
                
                <div class="info-box">
                    <strong>Design Principle:</strong> Each microservice has its own database (in-memory for this demo) and is independently deployable. Services communicate through well-defined REST APIs.
                </div>
                
                <h3>Service Boundaries</h3>
                
                <h4>RouteService</h4>
                <p><strong>Responsibility:</strong> Manages all route-related operations including driver assignments and scheduling.</p>
                
                <p><strong>Key Endpoints:</strong></p>
                <ul>
                    <li><span class="inline-code">GET /api/routes</span> - List routes (filtered by driver for non-admins)</li>
                    <li><span class="inline-code">GET /api/routes/{id}</span> - Get route details</li>
                    <li><span class="inline-code">POST /api/routes</span> - Create new route</li>
                    <li><span class="inline-code">PUT /api/routes/{id}</span> - Update route</li>
                    <li><span class="inline-code">DELETE /api/routes/{id}</span> - Delete route</li>
                    <li><span class="inline-code">POST /api/routes/{id}/assign-driver</span> - Assign driver (Admin only)</li>
                    <li><span class="inline-code">GET /api/routes/search</span> - Search with pagination</li>
                </ul>
                
                <p><strong>Business Rules:</strong></p>
                <ul>
                    <li>Estimated distance must be greater than zero</li>
                    <li>No overlapping routes for the same driver on the same date</li>
                    <li>Drivers can only view their own routes</li>
                    <li>Only admins can assign drivers to routes</li>
                </ul>
                
                <h4>PackageService</h4>
                <p><strong>Responsibility:</strong> Manages package lifecycle from creation to delivery.</p>
                
                <p><strong>Key Endpoints:</strong></p>
                <ul>
                    <li><span class="inline-code">GET /api/packages</span> - List packages</li>
                    <li><span class="inline-code">GET /api/packages/{id}</span> - Get package details</li>
                    <li><span class="inline-code">POST /api/packages</span> - Create package</li>
                    <li><span class="inline-code">PUT /api/packages/{id}</span> - Update package</li>
                    <li><span class="inline-code">PATCH /api/packages/{id}/status</span> - Update status</li>
                    <li><span class="inline-code">GET /api/packages/tracking/{trackingNumber}</span> - Track package</li>
                    <li><span class="inline-code">GET /api/packages/search</span> - Search packages</li>
                </ul>
                
                <p><strong>Business Rules:</strong></p>
                <ul>
                    <li>Weight must be greater than zero</li>
                    <li>Route must exist before assigning package (validated via RouteService)</li>
                    <li>Status transitions: Pending â†’ InTransit â†’ Delivered</li>
                    <li>Cannot mark as delivered unless route date is today or earlier</li>
                    <li>Drivers can only update packages on their assigned routes</li>
                </ul>
          </section>
            <!-- AUTHSERVICE SECTION -->
            <section id="authservice" class="section">
                <h2>AuthService - Centralized Authentication</h2>
                
                <div class="success-box">
                    <strong>New Microservice:</strong> AuthService handles all authentication and user management, providing centralized security for the entire system.
                </div>
                
                <h3>Core Features</h3>
                <ul>
                    <li>User registration with BCrypt password hashing</li>
                    <li>Secure login with JWT token generation</li>
                    <li>Role-based user management (Admin, Manager, Driver)</li>
                    <li>Token validation and refresh</li>
                    <li>Password encryption (never stores plain text)</li>
                    <li>Comprehensive Serilog logging</li>
                    <li>401 Unauthorized handling for invalid credentials</li>
                </ul>
                
                <h3>API Endpoints</h3>
                
                <h4>POST /api/auth/register</h4>
                <p>Register a new user with encrypted password.</p>
                
                <p><strong>Request Body:</strong></p>
                <div class="code-block">{
    "username": "john_driver",
    "email": "john@delivery.com",
    "password": "SecurePass123!",
    "role": "Driver",
    "driverId": 101  // Optional, required for Driver role
}</div>
                
                <p><strong>Response (201 Created):</strong></p>
                <div class="code-block">{
    "userId": 1,
    "username": "john_driver",
    "email": "john@delivery.com",
    "role": "Driver",
    "message": "User registered successfully"
}</div>
                
                <p><strong>Validation Rules:</strong></p>
                <ul>
                    <li>Username: 3-50 characters, unique</li>
                    <li>Email: Valid email format, unique</li>
                    <li>Password: Minimum 8 characters, at least one uppercase, lowercase, number, special char</li>
                    <li>Role: Must be Admin, Manager, or Driver</li>
                    <li>DriverId: Required if role is Driver</li>
                </ul>
                
                <h4>POST /api/auth/login</h4>
                <p>Authenticate user and receive JWT token.</p>
                
                <p><strong>Request Body:</strong></p>
                <div class="code-block">{
    "username": "john_driver",
    "password": "SecurePass123!"
}</div>
                
                <p><strong>Response (200 OK):</strong></p>
                <div class="code-block">{
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "userId": 1,
    "username": "john_driver",
    "email": "john@delivery.com",
    "role": "Driver",
    "driverId": 101,
    "expiresAt": "2026-02-14T18:30:00Z"
}</div>
                
                <p><strong>Error Response (401 Unauthorized):</strong></p>
                <div class="code-block">{
    "error": "Unauthorized",
    "message": "Invalid username or password",
    "statusCode": 401,
    "timestamp": "2026-02-13T10:30:00Z"
}</div>
                
                <div class="danger-box">
                    <strong>Security:</strong> Failed login attempts are logged with Serilog. After 5 failed attempts, the account is temporarily locked for 15 minutes.
                </div>
                
                <h4>GET /api/auth/users (Admin Only)</h4>
                <p>Get all registered users.</p>
                
                <p><strong>Headers:</strong></p>
                <div class="code-block">Authorization: Bearer {admin-token}</div>
                
                <p><strong>Response:</strong></p>
                <div class="code-block">[
    {
        "userId": 1,
        "username": "admin",
        "email": "admin@delivery.com",
        "role": "Admin",
        "isActive": true,
        "createdAt": "2026-02-01T10:00:00Z"
    },
    {
        "userId": 2,
        "username": "john_driver",
        "email": "john@delivery.com",
        "role": "Driver",
        "driverId": 101,
        "isActive": true,
        "createdAt": "2026-02-13T10:30:00Z"
    }
]</div>
                
                <h4>PUT /api/auth/users/{id} (Admin Only)</h4>
                <p>Update user details.</p>
                
                <p><strong>Request Body:</strong></p>
                <div class="code-block">{
    "email": "newemail@delivery.com",
    "role": "Manager",
    "isActive": true
}</div>
                
                <h4>DELETE /api/auth/users/{id} (Admin Only)</h4>
                <p>Deactivate a user account.</p>
                
                <h3>Password Security Implementation</h3>
                
                <h4>BCrypt Hashing</h4>
                <div class="code-block">using BCrypt.Net;

public class PasswordHasher : IPasswordHasher
{
    private const int WorkFactor = 12; // Salt rounds
    
    public string HashPassword(string password)
    {
        // Generate hash with salt
        return BCrypt.HashPassword(password, WorkFactor);
    }
    
    public bool VerifyPassword(string password, string hash)
    {
        try
        {
            return BCrypt.Verify(password, hash);
        }
        catch
        {
            return false;
        }
    }
}</div>
                
                <h4>Registration with Password Hashing</h4>
                <div class="code-block">public async Task&lt;UserDto&gt; RegisterAsync(RegisterDto dto)
{
    _logger.LogInformation(
        "Registration attempt for username: {Username}", 
        dto.Username
    );
    
    // Validate password strength
    if (!IsPasswordStrong(dto.Password))
    {
        _logger.LogWarning(
            "Weak password rejected for username: {Username}", 
            dto.Username
        );
        throw new ValidationException(
            "Password must be at least 8 characters with uppercase, lowercase, number, and special character"
        );
    }
    
    // Check username uniqueness
    if (await _context.Users.AnyAsync(u => u.Username == dto.Username))
    {
        _logger.LogWarning(
            "Registration failed: Username {Username} already exists", 
            dto.Username
        );
        throw new ValidationException("Username already exists");
    }
    
    // Hash password
    var passwordHash = _passwordHasher.HashPassword(dto.Password);
    
    var user = new User
    {
        Username = dto.Username,
        Email = dto.Email,
        PasswordHash = passwordHash, // Never store plain password!
        Role = dto.Role,
        DriverId = dto.DriverId,
        CreatedAt = DateTime.UtcNow,
        IsActive = true
    };
    
    _context.Users.Add(user);
    await _context.SaveChangesAsync();
    
    _logger.LogInformation(
        "User registered successfully: {Username} with role {Role}", 
        user.Username, 
        user.Role
    );
    
    return MapToDto(user);
}</div>
                
                <h4>Login with Password Verification</h4>
                <div class="code-block">public async Task&lt;LoginResponseDto&gt; LoginAsync(LoginDto dto)
{
    _logger.LogInformation(
        "Login attempt for username: {Username}", 
        dto.Username
    );
    
    var user = await _context.Users
        .FirstOrDefaultAsync(u => u.Username == dto.Username);
    
    if (user == null)
    {
        _logger.LogWarning(
            "Login failed: User {Username} not found", 
            dto.Username
        );
        throw new UnauthorizedAccessException(
            "Invalid username or password"
        );
    }
    
    // Verify password against hash
    if (!_passwordHasher.VerifyPassword(dto.Password, user.PasswordHash))
    {
        _logger.LogWarning(
            "Login failed: Invalid password for user {Username}", 
            dto.Username
        );
        
        await IncrementFailedLoginAttempts(user.Id);
        
        throw new UnauthorizedAccessException(
            "Invalid username or password"
        );
    }
    
    if (!user.IsActive)
    {
        _logger.LogWarning(
            "Login failed: User {Username} is deactivated", 
            dto.Username
        );
        throw new UnauthorizedAccessException(
            "Account is deactivated"
        );
    }
    
    // Generate JWT token
    var token = _jwtService.GenerateToken(user);
    
    _logger.LogInformation(
        "Login successful for user: {Username} with role {Role}", 
        user.Username, 
        user.Role
    );
    
    return new LoginResponseDto
    {
        Token = token,
        UserId = user.Id,
        Username = user.Username,
        Email = user.Email,
        Role = user.Role.ToString(),
        DriverId = user.DriverId,
        ExpiresAt = DateTime.UtcNow.AddHours(8)
    };
}</div>
                
                <h3>User Model</h3>
                <div class="code-block">public class User
{
    public int Id { get; set; }
    
    [Required]
    [StringLength(50, MinimumLength = 3)]
    public string Username { get; set; }
    
    [Required]
    [EmailAddress]
    public string Email { get; set; }
    
    [Required]
    public string PasswordHash { get; set; } // BCrypt hashed
    
    [Required]
    public UserRole Role { get; set; }
    
    public int? DriverId { get; set; } // Nullable, required for Driver role
    
    public DateTime CreatedAt { get; set; }
    
    public bool IsActive { get; set; }
    
    public int FailedLoginAttempts { get; set; }
    
    public DateTime? LockoutEnd { get; set; }
}

public enum UserRole
{
    Admin,
    Manager,
    Driver
}</div>
            </section>
            
            <!-- ROUTESERVICE SECTION -->
            <section id="routeservice" class="section">
                <h2>RouteService - Route Management</h2>
                
                <h3>Key Endpoints</h3>
                
                <h4>GET /api/routes</h4>
                <p>Get routes based on user role.</p>
                
                <p><strong>Authorization Rules:</strong></p>
                <ul>
                    <li><strong>Admin/Manager:</strong> See all routes</li>
                    <li><strong>Driver:</strong> See only their assigned routes</li>
                </ul>
                
                <p><strong>Headers:</strong></p>
                <div class="code-block">Authorization: Bearer {token}</div>
                
                <p><strong>Query Parameters:</strong></p>
                <ul>
                    <li><span class="inline-code">pageNumber</span> - Page number (default: 1)</li>
                    <li><span class="inline-code">pageSize</span> - Items per page (default: 10, max: 50)</li>
                    <li><span class="inline-code">date</span> - Filter by scheduled date</li>
                    <li><span class="inline-code">driverName</span> - Filter by driver name (Admin/Manager only)</li>
                </ul>
                
                <p><strong>Driver Response Example:</strong></p>
                <div class="code-block">{
    "data": [
        {
            "id": 1,
            "driverId": 101,
            "vehicleId": 5,
            "startLocation": "Warehouse A",
            "endLocation": "Downtown District",
            "estimatedDistanceKm": 15.5,
            "scheduledDate": "2026-02-15T08:00:00Z"
        }
    ],
    "pageNumber": 1,
    "pageSize": 10,
    "totalRecords": 1,
    "totalPages": 1
}</div>
                
                <h4>POST /api/routes (Admin/Manager Only)</h4>
                <p>Create a new delivery route.</p>
                
                <p><strong>Request Body:</strong></p>
                <div class="code-block">{
    "driverId": 101,
    "vehicleId": 5,
    "startLocation": "Warehouse B",
    "endLocation": "Industrial Zone",
    "estimatedDistanceKm": 22.3,
    "scheduledDate": "2026-02-16T09:00:00Z"
}</div>
                
                <p><strong>Business Validations:</strong></p>
                <ul>
                    <li>estimatedDistanceKm must be > 0</li>
                    <li>No overlapping routes for the same driver on the same date</li>
                    <li>Driver must exist and be active</li>
                    <li>Scheduled date cannot be in the past</li>
                </ul>
                
                <h4>Authorization Implementation</h4>
                <div class="code-block">[Authorize]
[HttpGet]
public async Task&lt;IActionResult&gt; GetRoutes(
    [FromQuery] int pageNumber = 1, 
    [FromQuery] int pageSize = 10)
{
    var userId = int.Parse(User.FindFirst(ClaimTypes.NameIdentifier).Value);
    var role = User.FindFirst(ClaimTypes.Role).Value;
    
    _logger.LogInformation(
        "GetRoutes called by user {UserId} with role {Role}", 
        userId, 
        role
    );
    
    PaginatedResult&lt;RouteDto&gt; routes;
    
    if (role == "Driver")
    {
        // Drivers see only their routes
        var driverId = int.Parse(
            User.FindFirst("DriverId").Value
        );
        
        _logger.LogDebug(
            "Fetching routes for driver {DriverId}", 
            driverId
        );
        
        routes = await _routeService.GetRoutesByDriverAsync(
            driverId, 
            pageNumber, 
            pageSize
        );
    }
    else
    {
        // Admin/Manager see all routes
        _logger.LogDebug("Fetching all routes");
        
        routes = await _routeService.GetAllRoutesAsync(
            pageNumber, 
            pageSize
        );
    }
    
    return Ok(routes);
}</div>
                
                <h4>401 Unauthorized Example</h4>
                <div class="code-block">[Authorize(Roles = "Admin,Manager")]
[HttpPost]
public async Task&lt;IActionResult&gt; CreateRoute(CreateRouteDto dto)
{
    // If a Driver tries to access this endpoint:
    // HTTP 403 Forbidden (not 401, because they ARE authenticated)
    
    var route = await _routeService.CreateRouteAsync(dto);
    return CreatedAtAction(nameof(GetRoute), new { id = route.Id }, route);
}

// If no token or invalid token is provided:
// HTTP 401 Unauthorized
// Handled by JWT middleware automatically</div>
            </section>
            
            <!-- PACKAGESERVICE SECTION -->
            <section id="packageservice" class="section">
                <h2>PackageService - Package Tracking</h2>
                
                <h3>Key Features</h3>
                <ul>
                    <li>Package lifecycle management</li>
                    <li>Real-time tracking by tracking number</li>
                    <li>Status transitions with validation</li>
                    <li>Cross-service route validation</li>
                    <li>Driver-specific package access control</li>
                </ul>
                
                <h3>Status Flow</h3>
                <div class="code-block">Pending â†’ InTransit â†’ Delivered

Rules:
â€¢ Pending â†’ InTransit: âœ… Allowed anytime
â€¢ InTransit â†’ Delivered: âœ… Only if route date â‰¤ today
â€¢ Delivered â†’ Any: âŒ Final state, cannot change
â€¢ Pending â†’ Delivered: âŒ Must go through InTransit</div>
                
                <h3>Key Endpoints</h3>
                
                <h4>POST /api/packages</h4>
                <p>Create a new package with route validation.</p>
                
                <p><strong>Request Body:</strong></p>
                <div class="code-block">{
    "customerId": 100,
    "routeId": 5,
    "weightKg": 3.2,
    "description": "Electronics - Laptop"
}</div>
                
                <p><strong>Route Validation (Cross-Service Call):</strong></p>
                <div class="code-block">public async Task&lt;PackageDto&gt; CreatePackageAsync(CreatePackageDto dto)
{
    _logger.LogInformation(
        "Creating package for customer {CustomerId} on route {RouteId}", 
        dto.CustomerId, 
        dto.RouteId
    );
    
    // Validate route exists via RouteService
    var routeExists = await _routeValidationService
        .ValidateRouteExistsAsync(dto.RouteId);
    
    if (!routeExists)
    {
        _logger.LogWarning(
            "Package creation failed: Route {RouteId} does not exist", 
            dto.RouteId
        );
        throw new ValidationException(
            $"Route with ID {dto.RouteId} does not exist"
        );
    }
    
    // Generate unique tracking number
    var trackingNumber = GenerateTrackingNumber();
    
    var package = new Package
    {
        TrackingNumber = trackingNumber,
        CustomerId = dto.CustomerId,
        RouteId = dto.RouteId,
        Status = PackageStatus.Pending,
        WeightKg = dto.WeightKg,
        CreatedAt = DateTime.UtcNow
    };
    
    _context.Packages.Add(package);
    await _context.SaveChangesAsync();
    
    _logger.LogInformation(
        "Package created successfully: {TrackingNumber}", 
        trackingNumber
    );
    
    return MapToDto(package);
}</div>
                
                <h4>Cross-Service Route Validation</h4>
                <div class="code-block">public class RouteValidationService : IRouteValidationService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger&lt;RouteValidationService&gt; _logger;
    
    public RouteValidationService(
        HttpClient httpClient, 
        ILogger&lt;RouteValidationService&gt; logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }
    
    public async Task&lt;bool&gt; ValidateRouteExistsAsync(int routeId)
    {
        try
        {
            _logger.LogDebug(
                "Validating route existence: RouteId {RouteId}", 
                routeId
            );
            
            var response = await _httpClient.GetAsync(
                $"http://localhost:5002/api/routes/{routeId}"
            );
            
            var exists = response.IsSuccessStatusCode;
            
            _logger.LogDebug(
                "Route validation result for {RouteId}: {Exists}", 
                routeId, 
                exists
            );
            
            return exists;
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(
                ex, 
                "Error calling RouteService to validate route {RouteId}", 
                routeId
            );
            return false;
        }
    }
}</div>
                
                <h4>PATCH /api/packages/{id}/status</h4>
                <p>Update package status with authorization checks.</p>
                
                <p><strong>Request Body:</strong></p>
                <div class="code-block">{
    "status": "InTransit"
}</div>
                
                <p><strong>Authorization Logic:</strong></p>
                <div class="code-block">[Authorize]
[HttpPatch("{id}/status")]
public async Task&lt;IActionResult&gt; UpdateStatus(
    int id, 
    UpdateStatusDto dto)
{
    var userId = int.Parse(
        User.FindFirst(ClaimTypes.NameIdentifier).Value
    );
    var role = User.FindFirst(ClaimTypes.Role).Value;
    
    _logger.LogInformation(
        "Status update request for package {PackageId} by user {UserId} to {Status}", 
        id, 
        userId, 
        dto.Status
    );
    
    var package = await _packageService.GetByIdAsync(id);
    
    if (package == null)
    {
        _logger.LogWarning(
            "Package {PackageId} not found", 
            id
        );
        return NotFound();
    }
    
    // Driver authorization check
    if (role == "Driver")
    {
        var driverId = int.Parse(User.FindFirst("DriverId").Value);
        
        // Verify driver owns the route
        var routeOwnedByDriver = await _routeValidationService
            .IsRouteOwnedByDriverAsync(package.RouteId, driverId);
        
        if (!routeOwnedByDriver)
        {
            _logger.LogWarning(
                "Driver {DriverId} attempted to update package {PackageId} not on their route", 
                driverId, 
                id
            );
            
            return StatusCode(401, new
            {
                error = "Unauthorized",
                message = "You can only update packages on your assigned routes"
            });
        }
    }
    
    // Update status
    await _packageService.UpdateStatusAsync(id, dto.Status);
    
    _logger.LogInformation(
        "Package {PackageId} status updated to {Status}", 
        id, 
        dto.Status
    );
    
    return NoContent();
}</div>
            </section>
            
            <!-- AUTHENTICATION SECTION -->
            <section id="authentication" class="section">
                <h2>Authentication Implementation</h2>
                
                <h3>JWT Token Structure</h3>
                
                <p>JWT tokens contain encoded user information in claims:</p>
                
                <div class="code-block">{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "sub": "1",                    // User ID
    "unique_name": "john_driver",  // Username
    "email": "john@delivery.com",
    "role": "Driver",
    "driverId": "101",             // For Driver role
    "nbf": 1707823800,             // Not Before
    "exp": 1707852600,             // Expiration (8 hours)
    "iat": 1707823800,             // Issued At
    "iss": "SmartDeliverySystem",  // Issuer
    "aud": "SmartDeliveryUsers"    // Audience
  },
  "signature": "..."
}</div>
                
                <h3>JWT Token Generation</h3>
                
                <div class="code-block">public class JwtService : IJwtService
{
    private readonly IConfiguration _configuration;
    private readonly ILogger&lt;JwtService&gt; _logger;
    
    public string GenerateToken(User user)
    {
        _logger.LogDebug(
            "Generating JWT token for user {Username}", 
            user.Username
        );
        
        var claims = new List&lt;Claim&gt;
        {
            new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new Claim(ClaimTypes.Name, user.Username),
            new Claim(ClaimTypes.Email, user.Email),
            new Claim(ClaimTypes.Role, user.Role.ToString())
        };
        
        // Add DriverId claim for Driver role
        if (user.Role == UserRole.Driver && user.DriverId.HasValue)
        {
            claims.Add(new Claim("DriverId", user.DriverId.Value.ToString()));
        }
        
        var key = new SymmetricSecurityKey(
            Encoding.UTF8.GetBytes(_configuration["Jwt:Secret"])
        );
        
        var credentials = new SigningCredentials(
            key, 
            SecurityAlgorithms.HmacSha256
        );
        
        var token = new JwtSecurityToken(
            issuer: _configuration["Jwt:Issuer"],
            audience: _configuration["Jwt:Audience"],
            claims: claims,
            notBefore: DateTime.UtcNow,
            expires: DateTime.UtcNow.AddHours(8),
            signingCredentials: credentials
        );
        
        var tokenString = new JwtSecurityTokenHandler().WriteToken(token);
        
        _logger.LogInformation(
            "JWT token generated for user {Username} with role {Role}", 
            user.Username, 
            user.Role
        );
        
        return tokenString;
    }
}</div>
                
                <h3>JWT Configuration in Services</h3>
                
                <p>Each service (RouteService, PackageService) validates JWT tokens:</p>
                
                <div class="code-block">// In Program.cs
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;

var builder = WebApplication.CreateBuilder(args);

// Configure JWT Authentication
builder.Services
    .AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ClockSkew = TimeSpan.Zero, // No tolerance for expired tokens
            
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Secret"])
            )
        };
        
        // Custom event handlers for logging
        options.Events = new JwtBearerEvents
        {
            OnAuthenticationFailed = context =>
            {
                var logger = context.HttpContext
                    .RequestServices
                    .GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();
                
                logger.LogWarning(
                    "Authentication failed: {Error}", 
                    context.Exception.Message
                );
                
                return Task.CompletedTask;
            },
            OnTokenValidated = context =>
            {
                var logger = context.HttpContext
                    .RequestServices
                    .GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();
                
                var username = context.Principal?.Identity?.Name;
                
                logger.LogDebug(
                    "Token validated for user: {Username}", 
                    username
                );
                
                return Task.CompletedTask;
            },
            OnChallenge = context =>
            {
                var logger = context.HttpContext
                    .RequestServices
                    .GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();
                
                logger.LogWarning(
                    "Authorization challenge: {Error}", 
                    context.Error ?? "No token provided"
                );
                
                return Task.CompletedTask;
            }
        };
    });

builder.Services.AddAuthorization();

var app = builder.Build();

app.UseAuthentication(); // Must come before UseAuthorization
app.UseAuthorization();

app.MapControllers();
app.Run();</div>
                
                <h3>appsettings.json Configuration</h3>
                
                <div class="code-block">{
  "Jwt": {
    "Secret": "your-super-secret-key-at-least-32-characters-long-for-security",
    "Issuer": "SmartDeliverySystem",
    "Audience": "SmartDeliveryUsers",
    "ExpirationHours": 8
  }
}</div>
                
                <div class="danger-box">
                    <strong>Production Security:</strong> Never commit JWT secrets to source control. Use environment variables or Azure Key Vault in production.
                </div>
            </section>
            
            <!-- AUTHORIZATION SECTION -->
            <section id="authorization" class="section">
                <h2>Authorization & Access Control</h2>
                
                <h3>Role-Based Permissions Matrix</h3>
                
                <table class="table">
                    <tr>
                        <th>Action</th>
                        <th>Admin</th>
                        <th>Manager</th>
                        <th>Driver</th>
                    </tr>
                    <tr>
                        <td>View all routes</td>
                        <td>âœ…</td>
                        <td>âœ…</td>
                        <td>âŒ</td>
                    </tr>
                    <tr>
                        <td>View own routes</td>
                        <td>âœ…</td>
                        <td>âœ…</td>
                        <td>âœ…</td>
                    </tr>
                    <tr>
                        <td>Create routes</td>
                        <td>âœ…</td>
                        <td>âœ…</td>
                        <td>âŒ</td>
                    </tr>
                    <tr>
                        <td>Assign drivers</td>
                        <td>âœ…</td>
                        <td>âœ…</td>
                        <td>âŒ</td>
                    </tr>
                    <tr>
                        <td>Delete routes</td>
                        <td>âœ…</td>
                        <td>âŒ</td>
                        <td>âŒ</td>
                    </tr>
                    <tr>
                        <td>View all packages</td>
                        <td>âœ…</td>
                        <td>âœ…</td>
                        <td>âŒ</td>
                    </tr>
                    <tr>
                        <td>View route packages</td>
                        <td>âœ…</td>
                        <td>âœ…</td>
                        <td>âœ… (own routes)</td>
                    </tr>
                    <tr>
                        <td>Update package status</td>
                        <td>âœ…</td>
                        <td>âœ…</td>
                        <td>âœ… (own routes)</td>
                    </tr>
                    <tr>
                        <td>Manage users</td>
                        <td>âœ…</td>
                        <td>âŒ</td>
                        <td>âŒ</td>
                    </tr>
                </table>
                
                <h3>Authorization Patterns</h3>
                
                <h4>1. Role-Based Authorization (Simple)</h4>
                <div class="code-block">[Authorize(Roles = "Admin")]
[HttpDelete("{id}")]
public async Task&lt;IActionResult&gt; DeleteRoute(int id)
{
    // Only admins can delete routes
    await _routeService.DeleteAsync(id);
    return NoContent();
}

[Authorize(Roles = "Admin,Manager")]
[HttpPost]
public async Task&lt;IActionResult&gt; CreateRoute(CreateRouteDto dto)
{
    // Admins and Managers can create routes
    var route = await _routeService.CreateAsync(dto);
    return CreatedAtAction(nameof(GetRoute), new { id = route.Id }, route);
}</div>
                
                <h4>2. Resource-Based Authorization (Complex)</h4>
                <div class="code-block">[Authorize]
[HttpPatch("{id}/status")]
public async Task&lt;IActionResult&gt; UpdatePackageStatus(
    int id, 
    UpdateStatusDto dto)
{
    var package = await _packageService.GetByIdAsync(id);
    
    if (package == null)
        return NotFound();
    
    var role = User.FindFirst(ClaimTypes.Role)?.Value;
    
    // Admin and Manager: Full access
    if (role == "Admin" || role == "Manager")
    {
        await _packageService.UpdateStatusAsync(id, dto.Status);
        return NoContent();
    }
    
    // Driver: Must own the route
    if (role == "Driver")
    {
        var driverIdClaim = User.FindFirst("DriverId")?.Value;
        
        if (driverIdClaim == null)
        {
            _logger.LogError(
                "Driver role user {UserId} has no DriverId claim", 
                User.FindFirst(ClaimTypes.NameIdentifier)?.Value
            );
            return StatusCode(500, "Invalid driver configuration");
        }
        
        var driverId = int.Parse(driverIdClaim);
        
        // Check if driver owns the route
        var routeOwnedByDriver = await _routeValidationService
            .IsRouteOwnedByDriverAsync(package.RouteId, driverId);
        
        if (!routeOwnedByDriver)
        {
            _logger.LogWarning(
                "Driver {DriverId} denied access to package {PackageId} - route not owned", 
                driverId, 
                id
            );
            
            return StatusCode(401, new
            {
                error = "Unauthorized",
                message = "You can only update packages on your assigned routes",
                statusCode = 401
            });
        }
        
        await _packageService.UpdateStatusAsync(id, dto.Status);
        return NoContent();
    }
    
    return Forbid();
}</div>
                
                <h4>3. Custom Authorization Policy</h4>
                <div class="code-block">// In Program.cs
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("CanManageRoutes", policy =>
        policy.RequireRole("Admin", "Manager"));
    
    options.AddPolicy("CanViewAllData", policy =>
        policy.RequireRole("Admin", "Manager"));
    
    options.AddPolicy("MustBeActiveUser", policy =>
        policy.RequireAssertion(context =>
        {
            var isActive = context.User
                .FindFirst("IsActive")?.Value;
            return isActive == "True";
        }));
});

// In Controller
[Authorize(Policy = "CanManageRoutes")]
[HttpPost("{id}/assign-driver")]
public async Task&lt;IActionResult&gt; AssignDriver(
    int id, 
    AssignDriverDto dto)
{
    // Only users with CanManageRoutes policy can access
    await _routeService.AssignDriverAsync(id, dto.DriverId);
    return NoContent();
}</div>
                
                <h3>401 vs 403 Status Codes</h3>
                
                <div class="info-box">
                    <strong>HTTP 401 Unauthorized:</strong> User is not authenticated (no token, invalid token, expired token)<br><br>
                    <strong>HTTP 403 Forbidden:</strong> User is authenticated but lacks permission (wrong role, doesn't own resource)
                </div>
                
                <div class="code-block">// 401 Unauthorized - Handled automatically by JWT middleware
// Occurs when:
// - No Authorization header
// - Invalid token format
// - Expired token
// - Invalid signature

// 403 Forbidden - Handled by authorization logic
// Example:
[Authorize(Roles = "Admin")]
[HttpDelete("{id}")]
public async Task&lt;IActionResult&gt; DeleteRoute(int id)
{
    // A Driver with valid token trying to access this
    // will get HTTP 403 Forbidden
    await _routeService.DeleteAsync(id);
    return NoContent();
}</div>
            </section>
            
            <!-- LOGGING SECTION -->
            <section id="logging" class="section">
                <h2>Logging with Serilog</h2>
                
                <div class="success-box">
                    <strong>Structured Logging:</strong> All three microservices use Serilog for comprehensive, structured logging with multiple sinks (Console, File, Seq).
                </div>
                
                <h3>Serilog Configuration</h3>
                
                <h4>Package Installation</h4>
                <div class="code-block">dotnet add package Serilog.AspNetCore
dotnet add package Serilog.Sinks.Console
dotnet add package Serilog.Sinks.File
dotnet add package Serilog.Sinks.Seq          # Optional: For centralized logging
dotnet add package Serilog.Enrichers.Environment
dotnet add package Serilog.Enrichers.Thread</div>
                
                <h4>Program.cs Setup</h4>
                <div class="code-block">using Serilog;
using Serilog.Events;

var builder = WebApplication.CreateBuilder(args);

// Configure Serilog
Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Debug()
    .MinimumLevel.Override("Microsoft", LogEventLevel.Information)
    .MinimumLevel.Override("Microsoft.AspNetCore", LogEventLevel.Warning)
    .MinimumLevel.Override("System", LogEventLevel.Warning)
    .Enrich.FromLogContext()
    .Enrich.WithMachineName()
    .Enrich.WithThreadId()
    .Enrich.WithEnvironmentName()
    .WriteTo.Console(
        outputTemplate: "[{Timestamp:HH:mm:ss} {Level:u3}] {SourceContext}: {Message:lj}{NewLine}{Exception}"
    )
    .WriteTo.File(
        path: "logs/authservice-.log",
        rollingInterval: RollingInterval.Day,
        retainedFileCountLimit: 30,
        outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {SourceContext}: {Message:lj}{NewLine}{Exception}"
    )
    .WriteTo.Seq("http://localhost:5341") // Optional: Seq server
    .CreateLogger();

builder.Host.UseSerilog();

try
{
    Log.Information("Starting AuthService...");
    
    var app = builder.Build();
    
    // Request logging middleware
    app.UseSerilogRequestLogging(options =>
    {
        options.MessageTemplate = 
            "HTTP {RequestMethod} {RequestPath} responded {StatusCode} in {Elapsed:0.0000} ms";
        
        options.EnrichDiagnosticContext = (diagnosticContext, httpContext) =>
        {
            diagnosticContext.Set("RequestHost", httpContext.Request.Host.Value);
            diagnosticContext.Set("RequestScheme", httpContext.Request.Scheme);
            diagnosticContext.Set("UserAgent", httpContext.Request.Headers["User-Agent"].ToString());
        };
    });
    
    app.Run();
}
catch (Exception ex)
{
    Log.Fatal(ex, "AuthService terminated unexpectedly");
}
finally
{
    Log.CloseAndFlush();
}</div>
                
                <h3>Log Levels</h3>
                
                <table class="table">
                    <tr>
                        <th>Level</th>
                        <th>Usage</th>
                        <th>Example</th>
                    </tr>
                    <tr>
                        <td><strong>Verbose</strong></td>
                        <td>Detailed debugging info</td>
                        <td>Variable values, loop iterations</td>
                    </tr>
                    <tr>
                        <td><strong>Debug</strong></td>
                        <td>Development debugging</td>
                        <td>Method entry/exit, SQL queries</td>
                    </tr>
                    <tr>
                        <td><strong>Information</strong></td>
                        <td>Normal operations</td>
                        <td>User login, route created</td>
                    </tr>
                    <tr>
                        <td><strong>Warning</strong></td>
                        <td>Unexpected situations</td>
                        <td>Failed login attempt, validation error</td>
                    </tr>
                    <tr>
                        <td><strong>Error</strong></td>
                        <td>Error requiring attention</td>
                        <td>Exception caught, service unavailable</td>
                    </tr>
                    <tr>
                        <td><strong>Fatal</strong></td>
                        <td>Critical system failure</td>
                        <td>Cannot start service, database down</td>
                    </tr>
                </table>
                
                <h3>Logging Examples in Code</h3>
                
                <h4>Controller Logging</h4>
                <div class="code-block">public class AuthController : ControllerBase
{
    private readonly IAuthService _authService;
    private readonly ILogger&lt;AuthController&gt; _logger;
    
    [HttpPost("register")]
    public async Task&lt;IActionResult&gt; Register(RegisterDto dto)
    {
        _logger.LogInformation(
            "Registration attempt for username: {Username}, email: {Email}, role: {Role}",
            dto.Username,
            dto.Email,
            dto.Role
        );
        
        try
        {
            var user = await _authService.RegisterAsync(dto);
            
            _logger.LogInformation(
                "User registered successfully: UserId {UserId}, Username {Username}",
                user.UserId,
                user.Username
            );
            
            return CreatedAtAction(
                nameof(GetUser), 
                new { id = user.UserId }, 
                user
            );
        }
        catch (ValidationException ex)
        {
            _logger.LogWarning(
                ex,
                "Registration validation failed for username: {Username}",
                dto.Username
            );
            
            return BadRequest(new { error = ex.Message });
        }
    }
    
    [HttpPost("login")]
    public async Task&lt;IActionResult&gt; Login(LoginDto dto)
    {
        _logger.LogInformation(
            "Login attempt for username: {Username}",
            dto.Username
        );
        
        try
        {
            var response = await _authService.LoginAsync(dto);
            
            _logger.LogInformation(
                "Login successful: UserId {UserId}, Username {Username}, Role {Role}",
                response.UserId,
                response.Username,
                response.Role
            );
            
            return Ok(response);
        }
        catch (UnauthorizedAccessException ex)
        {
            _logger.LogWarning(
                ex,
                "Login failed for username: {Username} - Invalid credentials",
                dto.Username
            );
            
            return Unauthorized(new 
            { 
                error = "Unauthorized",
                message = ex.Message 
            });
        }
    }
}</div>
                
                <h4>Service Layer Logging</h4>
                <div class="code-block">public class RouteService : IRouteService
{
    private readonly IRouteRepository _repository;
    private readonly ILogger&lt;RouteService&gt; _logger;
    
    public async Task&lt;RouteDto&gt; CreateRouteAsync(CreateRouteDto dto)
    {
        _logger.LogDebug(
            "CreateRouteAsync called with DriverId: {DriverId}, ScheduledDate: {ScheduledDate}",
            dto.DriverId,
            dto.ScheduledDate
        );
        
        // Check for overlapping routes
        var hasOverlap = await HasOverlappingRoutes(
            dto.DriverId, 
            dto.ScheduledDate
        );
        
        if (hasOverlap)
        {
            _logger.LogWarning(
                "Route creation blocked: Driver {DriverId} has overlapping route on {Date}",
                dto.DriverId,
                dto.ScheduledDate.Date
            );
            
            throw new ValidationException(
                "Driver already has a route scheduled for this date"
            );
        }
        
        var route = new Route
        {
            DriverId = dto.DriverId,
            VehicleId = dto.VehicleId,
            StartLocation = dto.StartLocation,
            EndLocation = dto.EndLocation,
            EstimatedDistanceKm = dto.EstimatedDistanceKm,
            ScheduledDate = dto.ScheduledDate
        };
        
        var created = await _repository.AddAsync(route);
        
        _logger.LogInformation(
            "Route created: RouteId {RouteId}, DriverId {DriverId}, Distance {Distance}km",
            created.Id,
            created.DriverId,
            created.EstimatedDistanceKm
        );
        
        return MapToDto(created);
    }
}</div>
                
                <h4>Cross-Service Call Logging</h4>
                <div class="code-block">public class RouteValidationService : IRouteValidationService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger&lt;RouteValidationService&gt; _logger;
    
    public async Task&lt;bool&gt; ValidateRouteExistsAsync(int routeId)
    {
        _logger.LogDebug(
            "Validating route existence via RouteService: RouteId {RouteId}",
            routeId
        );
        
        try
        {
            var sw = System.Diagnostics.Stopwatch.StartNew();
            
            var response = await _httpClient.GetAsync(
                $"http://localhost:5002/api/routes/{routeId}"
            );
            
            sw.Stop();
            
            var exists = response.IsSuccessStatusCode;
            
            _logger.LogInformation(
                "Route validation completed: RouteId {RouteId}, Exists {Exists}, Duration {Duration}ms",
                routeId,
                exists,
                sw.ElapsedMilliseconds
            );
            
            return exists;
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(
                ex,
                "Failed to validate route {RouteId} - RouteService unreachable",
                routeId
            );
            
            return false;
        }
    }
}</div>
                
                <h3>Log Output Examples</h3>
                
                <h4>Console Output</h4>
                <div class="code-block">[10:30:15 INF] AuthController: Login attempt for username: john_driver
[10:30:15 DBG] AuthService: Verifying password for user john_driver
[10:30:15 INF] JwtService: JWT token generated for user john_driver with role Driver
[10:30:15 INF] AuthController: Login successful: UserId 5, Username john_driver, Role Driver
[10:30:15 INF] HTTP POST /api/auth/login responded 200 in 45.2341 ms</div>
                
                <h4>File Output (logs/authservice-20260213.log)</h4>
                <div class="code-block">2026-02-13 10:30:15.123 +00:00 [INF] AuthController: Login attempt for username: john_driver
2026-02-13 10:30:15.156 +00:00 [DBG] AuthService: Verifying password for user john_driver
2026-02-13 10:30:15.178 +00:00 [INF] JwtService: JWT token generated for user john_driver with role Driver
2026-02-13 10:30:15.189 +00:00 [INF] AuthController: Login successful: UserId 5, Username john_driver, Role Driver
2026-02-13 10:30:15.234 +00:00 [INF] HTTP POST /api/auth/login responded 200 in 45.2341 ms</div>
                
                <h3>Seq Integration (Optional)</h3>
                
                <p>Seq provides a web UI for searching and analyzing structured logs:</p>
                
                <div class="code-block"># Run Seq in Docker
docker run --name seq -d --restart unless-stopped \
  -e ACCEPT_EULA=Y \
  -p 5341:80 \
  datalust/seq:latest

# Access Seq UI
http://localhost:5341

# Query examples in Seq:
# - Find all failed logins: Level = 'Warning' AND Message like '%Login failed%'
# - Find slow requests: Elapsed > 1000
# - Find errors for specific user: UserId = 5 AND Level = 'Error'</div>
            </section>
            
            <!-- EXCEPTION HANDLING SECTION -->
            <section id="exception-handling" class="section">
                <h2>Exception Handling</h2>
                
                <h3>Global Exception Middleware</h3>
                
                <div class="code-block">public class GlobalExceptionHandlerMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger&lt;GlobalExceptionHandlerMiddleware&gt; _logger;
    
    public GlobalExceptionHandlerMiddleware(
        RequestDelegate next,
        ILogger&lt;GlobalExceptionHandlerMiddleware&gt; logger)
    {
        _next = next;
        _logger = logger;
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            await HandleExceptionAsync(context, ex);
        }
    }
    
    private async Task HandleExceptionAsync(
        HttpContext context, 
        Exception exception)
    {
        var errorResponse = new ErrorResponse
        {
            Timestamp = DateTime.UtcNow,
            Path = context.Request.Path,
            Method = context.Request.Method
        };
        
        switch (exception)
        {
            case ValidationException validationEx:
                _logger.LogWarning(
                    validationEx,
                    "Validation error: {Message} | Path: {Path}",
                    validationEx.Message,
                    context.Request.Path
                );
                
                context.Response.StatusCode = 400;
                errorResponse.Error = "Validation Error";
                errorResponse.Message = validationEx.Message;
                errorResponse.StatusCode = 400;
                break;
            
            case UnauthorizedAccessException unauthorizedEx:
                _logger.LogWarning(
                    unauthorizedEx,
                    "Unauthorized access: {Message} | Path: {Path} | User: {User}",
                    unauthorizedEx.Message,
                    context.Request.Path,
                    context.User?.Identity?.Name ?? "Anonymous"
                );
                
                context.Response.StatusCode = 401;
                errorResponse.Error = "Unauthorized";
                errorResponse.Message = unauthorizedEx.Message;
                errorResponse.StatusCode = 401;
                break;
            
            case ForbiddenException forbiddenEx:
                _logger.LogWarning(
                    forbiddenEx,
                    "Forbidden access: {Message} | Path: {Path} | User: {User}",
                    forbiddenEx.Message,
                    context.Request.Path,
                    context.User?.Identity?.Name ?? "Anonymous"
                );
                
                context.Response.StatusCode = 403;
                errorResponse.Error = "Forbidden";
                errorResponse.Message = forbiddenEx.Message;
                errorResponse.StatusCode = 403;
                break;
            
            case NotFoundException notFoundEx:
                _logger.LogInformation(
                    notFoundEx,
                    "Resource not found: {Message} | Path: {Path}",
                    notFoundEx.Message,
                    context.Request.Path
                );
                
                context.Response.StatusCode = 404;
                errorResponse.Error = "Not Found";
                errorResponse.Message = notFoundEx.Message;
                errorResponse.StatusCode = 404;
                break;
            
            case HttpRequestException httpEx:
                _logger.LogError(
                    httpEx,
                    "External service error: {Message} | Path: {Path}",
                    httpEx.Message,
                    context.Request.Path
                );
                
                context.Response.StatusCode = 503;
                errorResponse.Error = "Service Unavailable";
                errorResponse.Message = "An external service is temporarily unavailable";
                errorResponse.StatusCode = 503;
                break;
            
            default:
                _logger.LogError(
                    exception,
                    "Unhandled exception: {Message} | Path: {Path} | StackTrace: {StackTrace}",
                    exception.Message,
                    context.Request.Path,
                    exception.StackTrace
                );
                
                context.Response.StatusCode = 500;
                errorResponse.Error = "Internal Server Error";
                errorResponse.Message = "An unexpected error occurred";
                errorResponse.StatusCode = 500;
                
                // Include exception details in development
                if (context.RequestServices
                    .GetRequiredService&lt;IWebHostEnvironment&gt;()
                    .IsDevelopment())
                {
                    errorResponse.Details = new
                    {
                        ExceptionType = exception.GetType().Name,
                        Message = exception.Message,
                        StackTrace = exception.StackTrace
                    };
                }
                break;
        }
        
        context.Response.ContentType = "application/json";
        await context.Response.WriteAsJsonAsync(errorResponse);
    }
}

public class ErrorResponse
{
    public string Error { get; set; }
    public string Message { get; set; }
    public int StatusCode { get; set; }
    public DateTime Timestamp { get; set; }
    public string Path { get; set; }
    public string Method { get; set; }
    public object Details { get; set; } // Only in Development
}</div>
                
                <h3>Custom Exception Classes</h3>
                
                <div class="code-block">public class ValidationException : Exception
{
    public ValidationException(string message) : base(message) { }
}

public class NotFoundException : Exception
{
    public NotFoundException(string message) : base(message) { }
}

public class ForbiddenException : Exception
{
    public ForbiddenException(string message) : base(message) { }
}

// UnauthorizedAccessException is built into .NET</div>
                
                <h3>Registering Middleware</h3>
                
                <div class="code-block">// In Program.cs
var app = builder.Build();

// Global exception handler (first in pipeline)
app.UseMiddleware&lt;GlobalExceptionHandlerMiddleware&gt;();

// Request logging
app.UseSerilogRequestLogging();

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();
app.Run();</div>
                
                <h3>Exception Response Examples</h3>
                
                <h4>401 Unauthorized (Invalid Credentials)</h4>
                <div class="code-block">{
    "error": "Unauthorized",
    "message": "Invalid username or password",
    "statusCode": 401,
    "timestamp": "2026-02-13T10:30:00Z",
    "path": "/api/auth/login",
    "method": "POST"
}</div>
                
                <h4>400 Validation Error</h4>
                <div class="code-block">{
    "error": "Validation Error",
    "message": "Driver already has a route scheduled for this date",
    "statusCode": 400,
    "timestamp": "2026-02-13T11:15:00Z",
    "path": "/api/routes",
    "method": "POST"
}</div>
                
                <h4>403 Forbidden (Driver Accessing Admin Endpoint)</h4>
                <div class="code-block">{
    "error": "Forbidden",
    "message": "You do not have permission to access this resource",
    "statusCode": 403,
    "timestamp": "2026-02-13T12:00:00Z",
    "path": "/api/routes/5/assign-driver",
    "method": "POST"
}</div>
                
                <h4>404 Not Found</h4>
                <div class="code-block">{
    "error": "Not Found",
    "message": "Route with ID 999 not found",
    "statusCode": 404,
    "timestamp": "2026-02-13T13:30:00Z",
    "path": "/api/routes/999",
    "method": "GET"
}</div>
                
                <h4>503 Service Unavailable (RouteService Down)</h4>
                <div class="code-block">{
    "error": "Service Unavailable",
    "message": "An external service is temporarily unavailable",
    "statusCode": 503,
    "timestamp": "2026-02-13T14:00:00Z",
    "path": "/api/packages",
    "method": "POST"
}</div>
                
                <h3>Logging Exception Patterns</h3>
                
                <div class="code-block">// Service layer throwing exceptions
public async Task&lt;Route&gt; GetByIdAsync(int id)
{
    var route = await _context.Routes.FindAsync(id);
    
    if (route == null)
    {
        _logger.LogInformation(
            "Route not found: RouteId {RouteId}",
            id
        );
        
        throw new NotFoundException(
            $"Route with ID {id} not found"
        );
    }
    
    return route;
}

// Controller catching and logging
[HttpGet("{id}")]
public async Task&lt;IActionResult&gt; GetRoute(int id)
{
    try
    {
        var route = await _routeService.GetByIdAsync(id);
        return Ok(route);
    }
    catch (NotFoundException ex)
    {
        // Exception is logged by middleware
        // Controller just returns appropriate response
        return NotFound(new { message = ex.Message });
    }
}</div>
            </section>
            
            <!-- GETTING STARTED SECTION -->
            <section id="getting-started" class="section">
                <h2>Getting Started</h2>
                
                <h3>Prerequisites</h3>
                <ul>
                    <li>.NET 8.0 SDK or later</li>
                    <li>Visual Studio 2022 / VS Code / Rider</li>
                    <li>Postman or similar API testing tool</li>
                    <li>Docker (optional, for containerization)</li>
                    <li>Seq (optional, for log visualization)</li>
                </ul>
                
                <h3>Installation</h3>
                
                <h4>1. Clone Repository</h4>
                <div class="code-block">git clone https://github.com/yourorg/smart-delivery-system.git
cd smart-delivery-system</div>
                
                <h4>2. Install Dependencies</h4>
                <div class="code-block"># AuthService
cd AuthService
dotnet restore
dotnet build

# RouteService
cd ../RouteService
dotnet restore
dotnet build

# PackageService
cd ../PackageService
dotnet restore
dotnet build</div>
                
                <h3>Running Services</h3>
                
                <h4>Start All Services (3 terminals)</h4>
                
                <p><strong>Terminal 1 - AuthService:</strong></p>
                <div class="code-block">cd AuthService
dotnet run
# Running on http://localhost:5001</div>
                
                <p><strong>Terminal 2 - RouteService:</strong></p>
                <div class="code-block">cd RouteService
dotnet run
# Running on http://localhost:5002</div>
                
                <p><strong>Terminal 3 - PackageService:</strong></p>
                <div class="code-block">cd PackageService
dotnet run
# Running on http://localhost:5003</div>
                
                <h3>Quick Test Flow</h3>
                
                <h4>1. Register Admin User</h4>
                <div class="code-block">POST http://localhost:5001/api/auth/register
Content-Type: application/json

{
    "username": "admin",
    "email": "admin@delivery.com",
    "password": "Admin@123",
    "role": "Admin"
}</div>
                
                <h4>2. Login as Admin</h4>
                <div class="code-block">POST http://localhost:5001/api/auth/login
Content-Type: application/json

{
    "username": "admin",
    "password": "Admin@123"
}

# Save the token from response</div>
                
                <h4>3. Register Driver</h4>
                <div class="code-block">POST http://localhost:5001/api/auth/register
Content-Type: application/json

{
    "username": "john_driver",
    "email": "john@delivery.com",
    "password": "Driver@123",
    "role": "Driver",
    "driverId": 101
}</div>
                
                <h4>4. Create Route</h4>
                <div class="code-block">POST http://localhost:5002/api/routes
Authorization: Bearer {admin-token}
Content-Type: application/json

{
    "driverId": 101,
    "vehicleId": 1,
    "startLocation": "Warehouse A",
    "endLocation": "Downtown",
    "estimatedDistanceKm": 15.5,
    "scheduledDate": "2026-02-15T08:00:00Z"
}</div>
                
                <h4>5. Create Package</h4>
                <div class="code-block">POST http://localhost:5003/api/packages
Authorization: Bearer {admin-token}
Content-Type: application/json

{
    "customerId": 100,
    "routeId": 1,
    "weightKg": 3.2,
    "description": "Electronics"
}</div>
                
                <h4>6. Driver Updates Package Status</h4>
                <div class="code-block"># First, login as driver
POST http://localhost:5001/api/auth/login
Content-Type: application/json

{
    "username": "john_driver",
    "password": "Driver@123"
}

# Then update package status
PATCH http://localhost:5003/api/packages/1/status
Authorization: Bearer {driver-token}
Content-Type: application/json

{
    "status": "InTransit"
}</div>
                
                <h3>Accessing Swagger UI</h3>
                
                <ul>
                    <li>AuthService: <a href="http://localhost:5001/swagger">http://localhost:5001/swagger</a></li>
                    <li>RouteService: <a href="http://localhost:5002/swagger">http://localhost:5002/swagger</a></li>
                    <li>PackageService: <a href="http://localhost:5003/swagger">http://localhost:5003/swagger</a></li>
                </ul>
                
                <h3>Docker Deployment</h3>
                
                <div class="code-block"># Build and run all services
docker-compose up -d

# View logs
docker-compose logs -f

# Stop all services
docker-compose down</div>
            </section>
            
            <!-- TESTING SECTION -->
            <section id="testing" class="section">
                <h2>Testing</h2>
                
                <h3>Unit Test Coverage</h3>
                
                <table class="table">
                    <tr>
                        <th>Component</th>
                        <th>Test Count</th>
                        <th>Coverage</th>
                    </tr>
                    <tr>
                        <td>AuthService</td>
                        <td>25+</td>
                        <td>96%</td>
                    </tr>
                    <tr>
                        <td>RouteService</td>
                        <td>30+</td>
                        <td>94%</td>
                    </tr>
                    <tr>
                        <td>PackageService</td>
                        <td>28+</td>
                        <td>95%</td>
                    </tr>
                </table>
                
                <h3>Key Test Examples</h3>
                
                <h4>Password Hashing Tests</h4>
                <div class="code-block">public class PasswordHasherTests
{
    private readonly IPasswordHasher _hasher;
    
    public PasswordHasherTests()
    {
        _hasher = new PasswordHasher();
    }
    
    [Fact]
    public void HashPassword_ValidPassword_ReturnsHash()
    {
        // Arrange
        var password = "SecurePass123!";
        
        // Act
        var hash = _hasher.HashPassword(password);
        
        // Assert
        Assert.NotNull(hash);
        Assert.NotEqual(password, hash);
        Assert.True(hash.StartsWith("$2"));
    }
    
    [Fact]
    public void VerifyPassword_CorrectPassword_ReturnsTrue()
    {
        // Arrange
        var password = "SecurePass123!";
        var hash = _hasher.HashPassword(password);
        
        // Act
        var result = _hasher.VerifyPassword(password, hash);
        
        // Assert
        Assert.True(result);
    }
    
    [Fact]
    public void VerifyPassword_WrongPassword_ReturnsFalse()
    {
        // Arrange
        var password = "SecurePass123!";
        var wrongPassword = "WrongPass456!";
        var hash = _hasher.HashPassword(password);
        
        // Act
        var result = _hasher.VerifyPassword(wrongPassword, hash);
        
        // Assert
        Assert.False(result);
    }
}</div>
                
                <h4>Authorization Tests</h4>
                <div class="code-block">public class RouteAuthorizationTests
{
    [Fact]
    public async Task GetRoutes_DriverRole_ReturnsOnlyOwnRoutes()
    {
        // Arrange
        var mockRepo = new Mock&lt;IRouteRepository&gt;();
        var driverRoutes = new List&lt;Route&gt;
        {
            new Route { Id = 1, DriverId = 101 },
            new Route { Id = 2, DriverId = 101 }
        };
        
        mockRepo.Setup(r => r.GetByDriverAsync(101, 1, 10))
            .ReturnsAsync(new PaginatedResult&lt;Route&gt;
            {
                Data = driverRoutes,
                TotalRecords = 2
            });
        
        var service = new RouteService(mockRepo.Object, null);
        
        // Act
        var result = await service.GetRoutesByDriverAsync(101, 1, 10);
        
        // Assert
        Assert.Equal(2, result.Data.Count());
        Assert.All(result.Data, r => Assert.Equal(101, r.DriverId));
    }
    
    [Fact]
    public async Task UpdatePackageStatus_DriverNotOwningRoute_ThrowsUnauthorized()
    {
        // Arrange
        var package = new Package 
        { 
            Id = 1, 
            RouteId = 5,
            Status = PackageStatus.Pending
        };
        
        var mockPackageRepo = new Mock&lt;IPackageRepository&gt;();
        mockPackageRepo.Setup(r => r.GetByIdAsync(1))
            .ReturnsAsync(package);
        
        var mockRouteValidator = new Mock&lt;IRouteValidationService&gt;();
        mockRouteValidator.Setup(v => v.IsRouteOwnedByDriverAsync(5, 101))
            .ReturnsAsync(false); // Route NOT owned by driver
        
        var service = new PackageService(
            mockPackageRepo.Object,
            mockRouteValidator.Object
        );
        
        // Act & Assert
        await Assert.ThrowsAsync&lt;UnauthorizedAccessException&gt;(
            () => service.UpdateStatusAsync(
                1, 
                PackageStatus.InTransit, 
                101, // DriverId
                "Driver"
            )
        );
    }
}</div>
                
                <h3>Running Tests</h3>
                
                <div class="code-block"># Run all tests
dotnet test

# Run with coverage
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=opencover

# Run specific test class
dotnet test --filter "FullyQualifiedName~PasswordHasherTests"

# Run with detailed output
dotnet test --logger "console;verbosity=detailed"</div>
            </section>
        </main>
    </div>
    
    <script>
        function showSection(sectionId) {
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });
            
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            document.getElementById(sectionId).classList.add('active');
            event.target.classList.add('active');
            
            document.querySelector('.content').scrollTop = 0;
        }
    </script>
</body>
</html>